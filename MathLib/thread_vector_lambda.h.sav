#pragma once
/* Enhancement to ThreadVector to run the threads in a lambda instead of in 
 * a separate static function.
 *
 * The template takes as parameters:
 *	typename T				The type (double, long double)
 *	size_t MIN_SLICE_SIZE	The minimum slice size, defaults to 10
 *	size_t MAX_THREADS		The maximum number of threads
 *
 * It will calculate the number of threads needed to run with at least the minimum
 * slice size.  The class will spawn up to the calculated number of threads - 1
 * threads.
 *
 * If the size is less than MIN_SLICE_SIZE then it will only run in the current
 * thread, and not spawn any more threads.
 */
#include "mathvectorbase.h"
#include "mathexception.h"
#include <thread>
namespace MathLib {
	template <typename T, size_t MIN_SLICE_SIZE = 10, size_t MAX_THREADS = 0>
	class ThreadVectorLambda : public MathVectorBase<T>
	{
	protected:
		using MathVectorBase<T>::size;
		using MathVectorBase<T>::arr;
		size_t num_threads;

		void setNumThreads() {
			num_threads = MAX_THREADS;
			if (num_threads < 0) {
				throw MathException(NUM_THREADS_LT_0);
			}

			if (num_threads > std::thread::hardware_concurrency() || num_threads == 0) {
				num_threads = std::thread::hardware_concurrency();
			}

			size_t num_slices = size / MIN_SLICE_SIZE;
			if (num_slices < 0) {
				num_threads = 1;
			}
			else if (num_slices < num_threads) {
				num_threads = num_slices;
			}
		}
	public:
		ThreadVectorLambda(size_t size) :MathVectorBase<T>(size) {
			setNumThreads();
		}

		ThreadVectorLambda() :MathVectorBase<T>() {
			setNumThreads();
		}

		ThreadVectorLambda(const std::initializer_list<T>& list) :MathVectorBase<T>(list) {
			setNumThreads();
		}
		~ThreadVectorLambda() {}

		T dotProduct(ThreadVectorLambda<T, MIN_SLICE_SIZE, MAX_THREADS>& v) {
			using namespace std;
			if (v.size != size) {
				throw MathException(VECTOR_SIZES_MUST_BE_THE_SAME);
			}

			// Split the array into num_thread slices
			//std::shared_ptr<T[]> result = std::make_shared<T[]>(num_threads);
			std::shared_ptr<T[]> result;
			result = std::make_unique<T[]>(num_threads);
			
			vector<std::thread> thd;

			T *a = arr;
			T *b = v.arr;
			T *end = arr;
			end += size;

			cout << "\nsize: " << size << " num_threads: " << num_threads << endl;

			if (num_threads > 1) {
				size_t slice = size / num_threads;
				// cout << "slice = " << slice << endl;
				T *a_end = a;
				for (size_t i = 0; i < num_threads - 1; ++i) {
					a_end += slice;
					cout << "a: " << a << " b: " << b << " a_end: " << a_end << " len: " << (a_end - a) << endl;
					thd.push_back(std::thread([=,this,&result, &a, &b]() {
						T sum = 0.0;
						while (a != a_end) {
							sum += (*a++) * (*b++);
						}
						result[i] = sum;
					}));
					a = a_end;
					b += slice;
				}
			} 

			// Run the last slice in the current thread
			T sum = 0.0;
			cout << "outside a: " << a << " b: " << b << " end: " << end << " len: " << (end - a) << endl;
			while (a != end) {
				sum += (*a++) * (*b++);
			}
			result[num_threads - 1] = sum;

			//std::cout << "range " << begin << " to " << size << " sum=" << sum << std::endl;

			// if (num_threads > 1) {
			// 	std::for_each(std::make_move_iterator(thd.begin()), std::make_move_iterator(thd.end()), [](std::thread t) 
			// 	{
			// 		t.join();
			// 	});
			// }
			if (num_threads > 1) {
				cout << "joining" << endl;
				// for (std::thread& t : thd) {
				// 	cout << "if joinable" << endl;
				// 	if (t.joinable()) {
				// 		cout << "  joining" << endl;
				// 		t.join();
 				// 		cout << " joined" << endl;
				// 	}
				// }

				std::for_each(thd.begin(), thd.end(), [](std::thread &t) 
    			{
					if (t.joinable()) { 
        				t.join();
					}
				});
			}

			// Sum up the slice results

			cout << "summing " << endl;
			sum = 0.0;
			for (size_t i = 0; i < num_threads; ++i) {
				sum += result[i];
			}

			return sum;
		}
	};
};
